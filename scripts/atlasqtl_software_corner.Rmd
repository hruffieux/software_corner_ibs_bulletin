---
title: "atlasqtl: an R package for variable selection in sparse regression with hierarchically-related responses"
author: "Hélène Ruffieux"
date: ""
output:
  bookdown::pdf_document2: 
    toc: false
    number_sections: false
classoption:
  - twocolumn
geometry: margin=0.7in
bibliography: references.bib
header-includes:
  - \usepackage[font={footnotesize, it}, labelfont={bf}]{caption}
---


```{r setup, echo=FALSE}

# We first set the data, output and main directories for the analysis (please 
# edit according to your own setup):

rm(list = ls())

CORE_DIR <- file.path(Sys.getenv("CORE_DIR"), "software_corner_ibs_bulletin/")

data_dir <- file.path(CORE_DIR, "data/")
fig_dir <- file.path(CORE_DIR, "figures/")
out_dir <- file.path(CORE_DIR, "output/")
main_dir <- file.path(CORE_DIR, "scripts/")
setwd(main_dir)
```

<!-- ### Context -->

Statistical studies aimed at identifying associations between a high-dimensional 
vector of candidate predictors and large numbers of correlated outcomes multiply, 
prompted by the proliferation of technologies capable of measuring large volumes 
of information, whether on health and lifestyle parameters, molecular entities or 
even galaxies. As well as growing in dimension, the datasets collected are also 
growing in complexity, which calls for elaborate and flexible modelling 
approaches. When coupled with robust and efficient inference, Bayesian 
hierarchical modelling is a powerful framework for describing intricate 
dependencies at the scale required by current applications, while conveying 
uncertainty in a coherent fashion. In this note, we present the R package 
`atlasqtl`, which implements a 
<!-- contributes to this endeavour by providing  -->
scalable hierarchical framework for variable selection in regression problems 
with high-dimensional predictor and response spaces.


## Model and inference 

The model consists of a series of hierarchically-related spike-and-slab 
regressions that permit borrowing information across a large number of 
responses. A graphical representation is provided in Figure 
\@ref(fig:figgm) --- the full prior specification 
<!-- and inference algorithm are  -->
is given in @ruffieux2020global. Each pair of predictor $X_s$ and response $y_t$ has a 
corresponding regression coefficient $\beta_{st}$ and spike-and-slab binary 
latent variable $\gamma_{st}$, from which posterior probabilities of association, 
$\text{pr}(\gamma_{st} = 1 \mid y)$, can be obtained and employed to 
implement Bayesian false discovery rate control. The model is also 
tailored to the detection of \emph{hotspots}, namely, predictors associated with 
several responses: the top-level hierarchy entails a probit submodel which 
involves a response-specific contribution to the spike-and-slab probability of 
association, via $\zeta_t$, and a predictor-specific modulation of this 
contribution, via $\theta_s$. The latter parameter also acts as the propensity 
of predictor $X_s$ to be a hotspot and is assigned a horseshoe prior; such a
global-local prior specification permits adapting to the overall problem 
sparsity (via the global scale $\sigma_0$), while flexibly capturing hotspot 
effects (via the Cauchy tail of the local scale $\lambda_s$). 
Joint inference requires special attention as the binary latent matrix 
$\Gamma = \{\gamma_{st}\}$ creates a discrete search space of dimension 
$2^{p\times q}$. To overcome this complication, `atlasqtl` implements a 
variational inference algorithm based on a structured mean-field factorisation 
and efficient batch updates. The algorithm is augmented with a simulated 
annealing scheme that improves the exploration of highly multimodal spaces by 
introducing so-called "temperature" parameters controlling the degree of 
separation of the modes of a series of "heated" distributions (@ruffieux2020global). 

<!-- `atlasqtl` provides an annealed variational inference routine for a  -->
<!-- series of hierarchically-related spike-and-slab regressions, thereby enabling  -->
<!-- information to be borrowed across very large numbers of responses. The model is  -->
<!-- also tailored to the detection of \emph{hotspots}, namely, predictors associated -->
<!-- with several responses, via a dedicated global-local horseshoe prior formulation. -->

`atlasqtl` can be employed in any sparse multiple-response regression 
setting. Hereafter we discuss a use case in the context of expression quantitative 
trait locus (eQTL) analysis, in which \emph{hotspot genetic variants}, 
controlling many gene expression traits at once, may be responsible for important 
functional mechanisms underlying specific disease endpoints --- such studies aim 
to clarify the genetic architecture of diseases by estimating associations 
between up to a few million candidate predictors (genetic variants) and several 
thousand responses (molecular traits, such as genomic, proteomic, metabolomic 
levels).

<!-- ### Model and algorithm -->

<!-- The model consists of a series of hierarchically-related regression, with $q$ centered responses, $y = (y_1, \ldots, y_q)$ and $p$ centered candidate predictors, $X = (X_1, \ldots, X_p)$ for $n$ samples ($n \ll p$). A graphical representation of the model is given in Figure XX.  -->
<!-- $$\begin{eqnarray} -->
<!-- y_t &\mid& \beta_t, \tau_t \sim \mathcal{N}_n\left( X\beta_t, \tau_t^{-1} I_n\right) , \hspace{4cm}  t = 1, \ldots, q\,,\nonumber\\ -->
<!-- \beta_{st} &\mid& \gamma_{st}, \tau_t, \sigma \sim \gamma_{st}\,\mathcal{N}\left( 0, \sigma^2\,\tau_{t}^{-1}\right)  + (1-\gamma_{st})\,\delta_0 \,, \hspace{1.45cm} s = 1, \ldots, p\,,\\ -->
<!-- \gamma_{st} &\mid&\theta_s, \zeta_t \sim \mathrm{Bern}\left\{ \Phi(\theta_s + \zeta_t) \right\},\qquad  \zeta_t \overset{\mathrm{iid}}{\sim}  \mathcal{N}(n_0, t_0^2),\nonumber\\ -->
<!-- \theta_s &\mid& \lambda_s, \sigma_0 \sim \mathcal{N}\left(0, \lambda_s^2 \sigma_0^2 \right), \qquad \lambda_s \overset{\mathrm{iid}}{\sim} \mathrm{C}^+(0, 1)\,, \qquad \sigma_0 \sim  \mathrm{C}^+(0, q^{-1/2})\,,\nonumber -->
<!-- \end{eqnarray}$$ -->
<!-- with Gamma prior distributions for $\tau_t$ and $\sigma^{-2}$; a graphical representation is given in Figure~\ref{fig_graph}. -->

<!-- ![Graphical representation of model (\ref{eq_all}). The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots.](../figures/gm.pdf){#id .class width=50% height=50%} -->

```{r figgm, echo=FALSE, fig.cap="Graphical representation of the model. The shaded nodes are observed, the others are inferred.", fig.align = 'center', out.width="80%"}
knitr::include_graphics("../figures/gm.png")
```

<!-- The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots. -->
## Installation

The `atlasqtl` package is written in R with C++ subroutines. It can be 
installed following the instructions provided at https://github.com/hruffieux/atlasqtl#installation. Note that the GSL library 
must be installed prior to installing the package.

## Data and reproducibility

The material used in this example is available at 
https://github.com/hruffieux/software_corner_ibs_bulletin
for replication purposes (Rmarkdown document). It involves synthetic genotyping 
data generated using our in-house R package `echoseq`; these data emulate real 
genotypes (single nucleotide polymorphisms, "SNPs") in the *LYZ* gene region. 
The gene expressionn traits consist of monocyte levels before and after immune 
stimulation (resting, IFNg, LPS2h, LPS24h), as well as B-cell levels. To each of 
these transcriptomic datasets corresponds a separate eQTL problem. 

<!-- The two steps:  -->

<!--   1) generation of synthetic SNPs from the real SNPs and  -->
<!--   2) modification of the expression levels to simulate genetic associations -->

<!-- are done using our in-house R package `echoseq` available at  -->
<!-- https://github.com/hruffieux/echoseq. While 1) requires access to the  -->
<!-- real genotyping data, 2) can be run using the R script `prepare_data.R`  -->
<!-- available in https://github.com/hruffieux/software_corner_ibs_bulletin -->
<!-- -- alternatively, one can directly use the `prepared_data.RData` R object file  -->
<!-- which contains ready-to-use datasets. We restricted the analyses to the most  -->
<!-- variable transcriptomic levels and to the $250$ SNPs surrounding the *LYZ* gene  -->
<!-- to limit the data file sizes and have the five eQTL analyses run within seconds  -->
<!-- on a standard laptop (parallel execution can be enabled). -->


## Analysis

<!-- -- the full analysis script can -->
<!-- be accessed at https://github.com/hruffieux/software_corner_ibs_bulletin/blob/master/scripts/atlasqtl_software_corner.Rmd.  -->


```{r data, echo=FALSE, results='hide'}

# We set a seed for reproducibility. The random generator "L'Ecuyer-CMRG" 
# ensures reproducibility when parallel processes are used.

RNGkind("L'Ecuyer-CMRG")
seed <- 1
set.seed(seed)

# The SNP and monocyte expression data are loaded (see `"Data and reproducibility" 
# Section above for details).
load(file.path(data_dir, "prepared_data.RData"))
ls()

p <- unique(sapply(list_data, function(ll_type) ncol(ll_type$snps)))
stopifnot(length(p) == 1) # all datasets involve the same number of SNPs

q <- unique(sapply(list_data, function(ll_type) ncol(ll_type$expr)))
stopifnot(length(q) == 1) # all datasets involve the same number of traits

n <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
n_check <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
stopifnot(all.equal(n, n_check)) # same number of samples for SNPs and traits within each eQTL problem
rm(n_check)

p # number of SNPs
q # number of traits in each eQTL problem
n # sample sizes in the five eQTL problems

bool_save <- FALSE # when TRUE, the analysis output is saved to a dedicated directory and the output and error messages are redirected to text files there.

if( bool_save ){
  res_dir <- paste0(out_dir, "atlasqtl_runs_seed_", seed, "/")
  dir.create(res_dir, showWarnings = FALSE)

  sink(paste(res_dir, "out.txt", sep = ""), append = F,
       split = T, type = "output")
  sink(file(paste(res_dir, "err.txt", sep = ""), open = "wt"),
       type = "message")
}
```

We illustrate the main package functionalities on the five eQTL problems 
(corresponding datasets stored in the list `list_data`). `atlasqtl` requires the 
specification of just two hyperparameters via the elicitation of a prior mean 
`mu_t` and variance `v_t` for the number of predictors associated with each 
response. The sensitivity of inference to these choices should be evaluated on a 
case-by-case basis; it is however very limited when a permutation-based FDR 
threshold is employed, where the "null-case" permutation runs use the same 
hyperparameter specifications. The remaining model parameters are inferred by 
variational inference. In particular, the horseshoe prior on the hotspot 
propensity circumvents ad-hoc choices of top-level variance parameters (for which
inference is prone to spurious effects). This specification also has desirable 
multiplicity adjustment properties in large-response settings, see 
@ruffieux2020global.

The code below runs the five `atlasqtl` analyses in parallel. The annealing 
schedule (initial temperature, grid size and type of spacing) can be supplied 
via the argument `anneal`; here we use a default geometric schedule on the 
inverse temperature, with initial temperature of $2$ and grid size of $10$. The 
argument `add_collinear_back` is a boolean indicating whether or not to include 
the final posterior summaries for all possible collinear variables in $X$ (which 
are removed during the run to ensure the stability of inference). A number of 
additional settings (e.g., tolerance, maximum number of iterations, 
checkpointing, etc.) can be chosen as detailed on the help page of the function, 
which is accessed by running `?atlasqtl` in the console. 

\footnotesize
```{r atlasqtl-load, include = TRUE, cache = FALSE, message=FALSE}
require(atlasqtl)
```

```{r atlasqtl-runs, include = TRUE, cache = TRUE, results = "hide"}

mu_t <- 1; v_t <- 4 # hyperparameter specification

vec_type <- names(list_data) # names of the eQTL problems 
                             # (resting, IFNg, LPS2h, 
                             # LPS24h monocytes and B-cells).

n_cpus <- 4 # nb of CPUs for parallel execution - please 
            # change this number according to your setup. 

list_out <- parallel::mclapply(vec_type, function(type) {

  snps <- list_data[[type]]$snps
  expr <- list_data[[type]]$expr
  
  atlasqtl(Y = expr, X = snps, 
           p0 = c(mu_t, v_t), 
           add_collinear_back = TRUE)
}, mc.cores = n_cpus)

names(list_out) <- vec_type
```
\normalsize 
The object returned by `atlasqtl` contains posterior quantities, which can be 
employed to assess:

   * pairwise associations between each pair of SNP and trait: using the 
variational posterior probabilities (PPIs) stored in `gam_vb`
($p \times q$ matrix) and the variational posterior means of the regression 
estimates stored in `beta_vb` ($p \times q$ matrix);
   * hotspot propensities: using the variational posterior mean of $\theta_s$ 
stored in `theta_vb` (vector of length $p$).

The custom `print.atlasqtl`, `summary.atlasqtl` and `plot.atlasqtl` S3 functions 
provide further information about the run and a summary of the above posterior 
quantities; e.g., for the LPS2h-monocyte eQTL analysis:


\footnotesize
```{r output-snapshot, include = TRUE}
print(list_out$lps2h) 
```
\normalsize 

The summary can optionnaly be based on a supplied Bayesian FDR threshold 
(here $5\%$); a $p \times q$ matrix of FDR estimates can also be directly 
obtained using the `assign_bFDR` function.

\footnotesize
```{r output-snapshot2, include = TRUE}
thres_fdr <- 0.05
summary(list_out$lps2h, thres = thres_fdr, 
        fdr_adjust = TRUE, full_summary = FALSE)
```

\normalsize 
```{r output-save, echo = FALSE}
if (bool_save) { # if `bool_save = TRUE`, the full output is saved in the directory created above.
  save(list_out, rt, file = paste(res_dir, "output.RData", sep = "")) 
}
```

The Manhattan-type plot indicates the position of the hotspots, as estimated in 
the five different eQTL analyses, using the Bayesian FDR threshold of $0.05$ on
the PPIs; alternatively, thanks to the scalability of the variational 
implementation, permutation-based Bayesian FDR can be obtained as an alternative 
(@ruffieux2017efficient and @ruffieux2020global).

\footnotesize
```{r manhattan-plot, echo = FALSE, fig.align = 'center', fig.cap="Hotspot sizes, as obtained using the S3 function plot.atlasqtl.", fig.align = 'center', out.width="90%"}
add <- FALSE
ylim_max <- max(unlist(lapply(list_out, function(ll_type) rowSums(assign_bFDR(ll_type$gam_vb)<thres_fdr)))) 
vec_pch <- c(15, 4, 2, 21, 20)

for (type_id in 1:5) {
  plot(list_out[[type_id]], thres = thres_fdr, fdr_adjust = TRUE, 
       pch = vec_pch[type_id], ylim_max = ylim_max, add = add)
  add <- TRUE  
}
legend("topleft", legend = vec_type, pch = vec_pch, bty = "n")
```
\normalsize 

## Encoding predictor-level information

We recently proposed a new approach, `epispot` (@ruffieux2021epispot) based on 
the same hierarchical framework, 
to encode and leverage information on the probability of candidate predictors to be 
involved in associations. Specifically, the effects of a (possibly high-dimensional) 
predictor-level vector of covariates are estimated using a secondary 
spike-and-slab regression at the top of the model hierarchy. The R package is 
available at https://github.com/hruffieux/epispot.

```{r session-info, echo = FALSE, results='hide'}
sessionInfo() # for reproducibility
```

\scriptsize
## References
