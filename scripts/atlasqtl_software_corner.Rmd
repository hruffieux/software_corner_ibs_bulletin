---
title: "atlasqtl: an R package for variable selection in sparse regression with hierarchically-related responses"
author: "Hélène Ruffieux"
date: ""
output:
  bookdown::pdf_document2: 
    toc: false
    number_sections: false
classoption:
  - twocolumn
geometry: margin=0.7in
bibliography: references.bib
header-includes:
  - \usepackage[font={footnotesize, it}, labelfont={bf}]{caption}
---


```{r setup, echo=FALSE}

# We first set the data, output and main directories for the analysis (please 
# edit according to your own setup):

rm(list = ls())

CORE_DIR <- file.path(Sys.getenv("CORE_DIR"), "software_corner_ibs_bulletin/")

data_dir <- file.path(CORE_DIR, "data/")
fig_dir <- file.path(CORE_DIR, "figures/")
out_dir <- file.path(CORE_DIR, "output/")
main_dir <- file.path(CORE_DIR, "scripts/")
setwd(main_dir)
```

Statistical studies aimed at identifying associations between a high-dimensional 
vector of candidate predictors and a series of correlated outcomes multiply, 
prompted by the proliferation of technologies capable of measuring large volumes 
of information, whether on health and lifestyle parameters, molecular entities 
or even galaxies. As well as growing in dimension, the collected datasets are 
also growing in complexity, which calls for elaborate and flexible modelling 
approaches. When coupled with robust and efficient inference, Bayesian 
hierarchical modelling is a powerful framework for describing intricate 
dependencies at the scale required by current applications, while conveying 
uncertainty in a coherent fashion. In this note, we present the R package 
`atlasqtl`, which implements a scalable hierarchical framework for variable 
selection in regression problems with high-dimensional predictor and response 
spaces.


### Model and inference 

The model consists of a series of hierarchically-related spike-and-slab 
regressions that permit borrowing information across a large number of 
responses. Specifically, to each pair of predictor $X_s$ and response $y_t$ 
corresponds a regression coefficient $\beta_{st}$ and a spike-and-slab binary 
latent variable $\gamma_{st}$; posterior probabilities of association, 
$\text{pr}(\gamma_{st} = 1 \mid y)$, can thus be obtained and employed to 
implement a Bayesian false discovery rate control. The model is also tailored to 
the detection of \emph{hotspots}, namely, predictors associated with multiple 
responses: the top-level hierarchy entails a probit submodel which involves a 
response-specific contribution to the spike-and-slab probability of association, 
via $\zeta_t$, and a predictor-specific modulation of this contribution, via 
$\theta_s$. The latter parameter also acts as the propensity of predictor $X_s$ 
to be a hotspot and is assigned a horseshoe prior --- the corresponding 
global-local specification adapts to the overall problem sparsity (thanks to the 
global scale $\sigma_0$), while flexibly capturing the individual hotspot 
effects (thanks to the Cauchy tail of the local scale $\lambda_s$). A graphical 
representation of the model is provided in Figure \@ref(fig:figgm) and its full 
specification is given in @ruffieux2020global.

Joint inference requires special attention as the binary latent matrix 
$\Gamma = \{\gamma_{st}\}$ creates a discrete search space of dimension 
$2^{p\times q}$, where $p$ and $q$ are the number of predictors and responses, 
respectively. To overcome this complication, `atlasqtl` relies on variational 
inference, with a structured mean-field factorisation and efficient batch 
updates. The algorithm is augmented with a simulated annealing scheme that 
improves the exploration of highly multimodal spaces by introducing so-called 
"temperature" parameters controlling the degree of separation of the modes for a 
series of "heated" distributions (@ruffieux2020global). 

`atlasqtl` can be employed in any sparse multiple-response regression setting 
with Gaussian errors. Hereafter we discuss a use case in the context of 
expression quantitative trait locus (eQTL) analysis, in which 
\emph{hotspot genetic variants}, controlling many gene expression traits at 
once, may be responsible for important functional mechanisms underlying specific 
disease endpoints --- such studies aim to clarify the genetic architecture of 
diseases by estimating associations between several thousand responses 
(molecular traits, such as genomic, proteomic, metabolomic levels) and up to a 
few million candidate predictors (genetic variants).

```{r figgm, echo=FALSE, fig.cap="Graphical representation of the model with $n$ samples, $p$ candidate predictors and $q$ responses. The shaded nodes are observed, the others are inferred.", fig.align = 'center', out.width="80%"}
knitr::include_graphics("../figures/gm.png")
```

### Installation

The `atlasqtl` package is written in R with C++ subroutines. It can be installed 
following the instructions provided on 
GitHub\footnote{\url{https://github.com/hruffieux/atlasqtl}}. 

### Data and reproducibility

The material (incl. Rmarkdown document) used in the example below is publicly 
available\footnote{\url{https://github.com/hruffieux/software_corner_ibs_bulletin}} 
for replication purposes. It involves synthetic genotyping data generated using 
our in-house R package `echoseq`; these data emulate real genotypes (single 
nucleotide polymorphisms, "SNPs") located in the *LYZ* gene region, on 
chromosome 12. The gene expression traits consist of monocyte levels before and 
after immune stimulation (resting, IFNg, LPS2h, LPS24h), as well as B-cell 
levels. To each of these transcriptomic datasets corresponds a separate eQTL 
problem. 

### Case study: an eQTL analysis to understand gene regulation in monocytes and B cells

```{r data, echo=FALSE, results='hide'}

# We set a seed for reproducibility. The random generator "L'Ecuyer-CMRG" 
# ensures reproducibility when parallel processes are used.

RNGkind("L'Ecuyer-CMRG")
seed <- 1
set.seed(seed)

# The SNP and monocyte expression data are loaded (see `"Data and 
# reproducibility" Section above for details).
load(file.path(data_dir, "prepared_data.RData"))
ls()

p <- unique(sapply(list_data, function(ll_type) ncol(ll_type$snps)))
stopifnot(length(p) == 1) # all datasets involve the same number of SNPs

q <- unique(sapply(list_data, function(ll_type) ncol(ll_type$expr)))
stopifnot(length(q) == 1) # all datasets involve the same number of traits

n <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
n_check <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
stopifnot(all.equal(n, n_check)) # same number of samples for SNPs and traits 
                                 # within each eQTL problem
rm(n_check)

p # number of SNPs
q # number of traits in each eQTL problem
n # sample sizes in the five eQTL problems

bool_save <- FALSE # when TRUE, the analysis output is saved to a dedicated 
                   # directory and the output and error messages are redirected 
                   # to text files there.

if( bool_save ){
  res_dir <- paste0(out_dir, "atlasqtl_runs_seed_", seed, "/")
  dir.create(res_dir, showWarnings = FALSE)

  sink(paste(res_dir, "out.txt", sep = ""), append = F,
       split = T, type = "output")
  sink(file(paste(res_dir, "err.txt", sep = ""), open = "wt"),
       type = "message")
}
```

We illustrate the main package functionalities on the five eQTL problems 
(corresponding datasets stored in `list_data`). `atlasqtl` requires the 
specification of just two hyperparameters via the elicitation of a prior mean 
`mu_t` and variance `v_t` for the number of predictors associated with each 
response. The sensitivity of inference to these choices should be evaluated on a 
case-by-case basis; it is however low when a permutation-based Bayesian FDR 
threshold is employed, where the "null-case" permutation runs use the same 
hyperparameter specifications. The remaining model parameters are inferred by 
variational inference. In particular, the horseshoe prior on the hotspot 
propensity circumvents \emph{ad-hoc} choices of top-level variance parameters 
(for which inference is prone to spurious effects). This specification also has 
desirable multiplicity adjustment properties in large-response settings, see 
@ruffieux2020global.

The code below runs the five `atlasqtl` analyses in parallel. The annealing 
schedule (initial temperature, grid size and type of spacing) can be supplied 
via the argument `anneal`; here we use a default geometric schedule on the 
inverse temperature, with initial temperature of $2$ and grid size of $10$. The 
argument `add_collinear_back` is a boolean indicating whether or not to include 
the final posterior summaries for all possible collinear variables in $X$ (which 
are removed during the run to ensure the stability of inference). A number of 
additional settings (e.g., tolerance for the variational algorithm, maximum 
number of iterations, checkpointing, etc.) can be chosen as detailed on the help 
page of the function, which can be accessed by running `?atlasqtl` in the 
console. 

\footnotesize
```{r atlasqtl-load, include = TRUE, cache = FALSE, message=FALSE}
require(atlasqtl)
```

```{r atlasqtl-runs, include = TRUE, cache = TRUE, results = "hide"}

mu_t <- 1; v_t <- 4 # hyperparameter specification

vec_type <- names(list_data) # names of the eQTL problems 
                             # (resting, IFNg, LPS2h, 
                             # LPS24h monocytes and B-cells).

n_cpus <- 4 # nb of CPUs for parallel execution - please 
            # alter according to your setup. 

list_out <- parallel::mclapply(vec_type, function(type) {

  snps <- list_data[[type]]$snps
  expr <- list_data[[type]]$expr
  
  atlasqtl(Y = expr, X = snps, 
           p0 = c(mu_t, v_t), 
           add_collinear_back = TRUE)
}, mc.cores = n_cpus)

names(list_out) <- vec_type
```
\normalsize 
The object returned by `atlasqtl` contains posterior quantities that can be 
employed to assess:

   * pairwise associations between each pair of predictor and response: using 
   the variational posterior probabilities of association (PPAs) stored in 
   `gam_vb` ($p \times q$ matrix) and the variational posterior means of the 
   regression estimates stored in `beta_vb` ($p \times q$ matrix);
   * hotspot propensities: using the variational posterior mean of $\theta_s$ 
stored in `theta_vb` (vector of length $p$).

The custom `print.atlasqtl`, `summary.atlasqtl` and `plot.atlasqtl` S3 functions 
provide further information about the run and a summary of the above posterior 
quantities; for instance, for the LPS2h-monocyte eQTL analysis:


\footnotesize
```{r output-snapshot, include = TRUE}
list_out$lps2h
```
\normalsize 

The summary can optionally be based on a supplied Bayesian FDR threshold 
(here $5\%$); alternatively a $p \times q$ matrix of FDR estimates can be 
directly obtained using the `assign_bFDR` function.

\footnotesize
```{r output-snapshot2, include = TRUE}
thres_fdr <- 0.05
summary(list_out$lps2h, thres = thres_fdr, 
        fdr_adjust = TRUE, full_summary = FALSE)
```

\normalsize 
```{r output-save, echo = FALSE}
if (bool_save) { # if `bool_save = TRUE`, the full output is saved in the 
                 # directory created above.
  save(list_out, rt, file = paste(res_dir, "output.RData", sep = "")) 
}
```

The Manhattan-type plot indicates the position of the hotspots, as estimated in 
the five different eQTL analyses, after Bayesian FDR control. Thanks to the 
scalability of the variational implementation, a permutation-based 
Bayesian FDR control can also be used (@ruffieux2017efficient and 
@ruffieux2020global).

\footnotesize
```{r manhattan-plot, echo = FALSE, fig.align = 'center', fig.cap="Hotspot sizes, as obtained using the S3 function plot.atlasqtl.", fig.align = 'center', out.width="90%"}
add <- FALSE
ylim_max <- max(unlist(lapply(list_out, function(ll_type) rowSums(assign_bFDR(ll_type$gam_vb)<thres_fdr)))) 
vec_pch <- c(15, 4, 2, 21, 20)

for (type_id in 1:5) {
  plot(list_out[[type_id]], thres = thres_fdr, fdr_adjust = TRUE, 
       pch = vec_pch[type_id], ylim_max = ylim_max, add = add)
  add <- TRUE  
}
legend("topleft", legend = vec_type, pch = vec_pch, bty = "n")
```
\normalsize 

### Encoding predictor-level information

We recently proposed a new approach, called `epispot`, which 
extends the `atlasqtl` hierarchical framework to encode and leverage information 
on the probability of candidate predictors to be involved in associations 
(@ruffieux2021epispot). Specifically, the effect of a (possibly 
high-dimensional) predictor-level vector of covariates is estimated using a 
secondary spike-and-slab regression at the top of the model hierarchy. The R 
package is available on 
GitHub\footnote{\url{https://github.com/hruffieux/epispot}}.

```{r session-info, echo = FALSE, results='hide'}
sessionInfo() # for reproducibility
```

\small
### References
