---
title: "atlasqtl: an R package for variable selection in sparse regression with hierarchically-related outcomes"
author: "Hélène Ruffieux"
date: "06/15/2022"
output:
  bookdown::pdf_document2: 
    toc: false
    number_sections: false
classoption:
  - twocolumn
geometry: margin=0.7in
bibliography: references.bib
---

```{r setup, echo=FALSE}

# We first set the data, output and main directories for the analysis (please 
# edit according to your own setup):

rm(list = ls())

CORE_DIR <- file.path(Sys.getenv("CORE_DIR"), "software_corner_ibs_bulletin/")

data_dir <- file.path(CORE_DIR, "data/")
fig_dir <- file.path(CORE_DIR, "figures/")
out_dir <- file.path(CORE_DIR, "output/")
main_dir <- file.path(CORE_DIR, "scripts/")
setwd(main_dir)
```

<!-- ### Context -->

Statistical problems 
<!-- involving high-dimensional set-ups  -->
in the high-dimensional setting multiply, prompted by 
the proliferation of technologies capable of measuring large volumes of 
information, whether on health and lifestyle parameters, molecular entities or 
even galaxies. As well as growing in dimension, the datasets collected are also 
growing in complexity, which calls for elaborate and flexible modelling 
approaches. When coupled with robust and efficient inference, Bayesian 
hierarchical modelling is a powerful framework for describing intricate 
dependencies at the scale required by current applications, while conveying 
uncertainty in a coherent fashion. In this note, we present the R package 
`atlasqtl`, which implements a 
<!-- contributes to this endeavour by providing  -->
scalable hierarchical framework for variable selection in regression problems 
with high-dimensional predictor and response spaces.


## Model and inference 

The model consists of series of hierarchically-related spike-and-slab 
regressions that permit borrowing information across large numbers of 
responses. A graphical representation is provided in Figure 
\@ref(fig:figgm), and the full model and inference algorithm are detailed in @ruffieux2020global. Each pair of predictor $X_s$ and response $y_t$ has its 
corresponding regression coefficient $\beta_{st}$ and spike-and-slab binary 
latent variable $\gamma_{st}$, from which posterior probabilities of association 
are conveniently obtained, $\text{pr}(\gamma_{st} = 1 \mid y)$, and employed to 
implement Bayesian false discovery rate control. The model is also 
tailored to the detection of \emph{hotspots}, namely, predictors associated with 
several responses: the top-level hierarchy entails a probit submodel which 
involves a response-specific contribution to the spike-and-slab probability of 
association, via $\zeta_t$, and a predictor-specific modulation of this 
contribution, via $\theta_s$. The latter parameter also acts as the propensity 
of predictor $X_s$ to be a hotspot and is assigned a horseshoe prior, which 
adapts to the overall problem sparsity (via the global scale $\sigma_0$), while 
flexibly capturing hotspot effects (via the Cauchy tail of the local scale $\lambda_s$). 
Joint inference requires special attention as the binary latent matrix 
$\Gamma = \{\gamma_{st}\}$ creates a discrete search space of dimension 
$2^{p\times q}$. To overcome this complication, `atlasqtl` implements a 
variational inference algorithm based on a structured mean-field factorisation 
and efficient batch updates. The algorithm is augmented with a simulated 
annealing scheme that improves the exploration of highly multimodal spaces by 
introducing so-called "temperature" parameters controlling the degree of 
separation of the modes of a series of "heated" distributions (@ruffieux2020global). 

<!-- `atlasqtl` provides an annealed variational inference routine for a  -->
<!-- series of hierarchically-related spike-and-slab regressions, thereby enabling  -->
<!-- information to be borrowed across very large numbers of responses. The model is  -->
<!-- also tailored to the detection of \emph{hotspots}, namely, predictors associated -->
<!-- with several responses, via a dedicated global-local horseshoe prior formulation. -->

`atlasqtl` can be employed in any sparse multiple-response regression 
setting. Hereafter we discuss a use case in the context of expression quantitative 
trait locus (eQTL) analysis, in which \emph{hotspot genetic variants}, 
controlling many molecular traits at once, may be responsible for important 
functional mechanisms underlying specific disease endpoints --- such studies aim 
to clarify the genetic architecture of diseases by estimating associations 
between up to a few million candidate predictors (genetic variants) and several 
thousand responses (molecular traits, such as genomic, proteomic, metabolomic 
levels).

<!-- ### Model and algorithm -->

<!-- The model consists of a series of hierarchically-related regression, with $q$ centered responses, $y = (y_1, \ldots, y_q)$ and $p$ centered candidate predictors, $X = (X_1, \ldots, X_p)$ for $n$ samples ($n \ll p$). A graphical representation of the model is given in Figure XX.  -->
<!-- $$\begin{eqnarray} -->
<!-- y_t &\mid& \beta_t, \tau_t \sim \mathcal{N}_n\left( X\beta_t, \tau_t^{-1} I_n\right) , \hspace{4cm}  t = 1, \ldots, q\,,\nonumber\\ -->
<!-- \beta_{st} &\mid& \gamma_{st}, \tau_t, \sigma \sim \gamma_{st}\,\mathcal{N}\left( 0, \sigma^2\,\tau_{t}^{-1}\right)  + (1-\gamma_{st})\,\delta_0 \,, \hspace{1.45cm} s = 1, \ldots, p\,,\\ -->
<!-- \gamma_{st} &\mid&\theta_s, \zeta_t \sim \mathrm{Bern}\left\{ \Phi(\theta_s + \zeta_t) \right\},\qquad  \zeta_t \overset{\mathrm{iid}}{\sim}  \mathcal{N}(n_0, t_0^2),\nonumber\\ -->
<!-- \theta_s &\mid& \lambda_s, \sigma_0 \sim \mathcal{N}\left(0, \lambda_s^2 \sigma_0^2 \right), \qquad \lambda_s \overset{\mathrm{iid}}{\sim} \mathrm{C}^+(0, 1)\,, \qquad \sigma_0 \sim  \mathrm{C}^+(0, q^{-1/2})\,,\nonumber -->
<!-- \end{eqnarray}$$ -->
<!-- with Gamma prior distributions for $\tau_t$ and $\sigma^{-2}$; a graphical representation is given in Figure~\ref{fig_graph}. -->

<!-- ![Graphical representation of model (\ref{eq_all}). The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots.](../figures/gm.pdf){#id .class width=50% height=50%} -->

```{r figgm, echo=FALSE, fig.cap="Graphical representation of the model. The shaded nodes are observed, the others are inferred.", fig.align = 'center', out.width="90%"}
knitr::include_graphics("../figures/gm.png")
```

<!-- The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots. -->
## Installation

The `atlasqtl` package is written in R with C++ subroutines. It can be 
installed following the instructions provided at https://github.com/hruffieux/atlasqtl#installation. Note that the GSL library 
must be installed prior to installing the package.

## Data and reproducibility

The material used in this example is available at 
https://github.com/hruffieux/software_corner_ibs_bulletin
for replication purposes. It involves synthetic genotyping data generated using 
our in-house R package `echoseq`  
(https://github.com/hruffieux/echoseq); these data emulate real genotypes (single 
nucleotide polymorphisms, "SNPs") in the *LYZ* gene region, which cannot be 
shared without data access agreement. The expression data consist of monocyte 
levels before and after immune stimulation (resting, IFNg, LPS2h, LPS24h), as 
well as B-cell levels. To each of these transcriptomic datasets corresponds a 
separate eQTL problem. 

<!-- The two steps:  -->

<!--   1) generation of synthetic SNPs from the real SNPs and  -->
<!--   2) modification of the expression levels to simulate genetic associations -->

<!-- are done using our in-house R package `echoseq` available at  -->
<!-- https://github.com/hruffieux/echoseq. While 1) requires access to the  -->
<!-- real genotyping data, 2) can be run using the R script `prepare_data.R`  -->
<!-- available in https://github.com/hruffieux/software_corner_ibs_bulletin -->
<!-- -- alternatively, one can directly use the `prepared_data.RData` R object file  -->
<!-- which contains ready-to-use datasets. We restricted the analyses to the most  -->
<!-- variable transcriptomic levels and to the $250$ SNPs surrounding the *LYZ* gene  -->
<!-- to limit the data file sizes and have the five eQTL analyses run within seconds  -->
<!-- on a standard laptop (parallel execution can be enabled). -->


## Analysis

<!-- -- the full analysis script can -->
<!-- be accessed at https://github.com/hruffieux/software_corner_ibs_bulletin/blob/master/scripts/atlasqtl_software_corner.Rmd.  -->


```{r data, echo=FALSE, results='hide'}

# We set a seed for reproducibility. The random generator "L'Ecuyer-CMRG" 
# ensures reproducibility when parallel processes are used.

RNGkind("L'Ecuyer-CMRG")
seed <- 1
set.seed(seed)

# The SNP and monocyte expression data are loaded (see `"Data and reproducibility" 
# Section above for details).
load(file.path(data_dir, "prepared_data.RData"))
ls()

p <- unique(sapply(list_data, function(ll_type) ncol(ll_type$snps)))
stopifnot(length(p) == 1) # all datasets involve the same number of SNPs

q <- unique(sapply(list_data, function(ll_type) ncol(ll_type$expr)))
stopifnot(length(q) == 1) # all datasets involve the same number of traits

n <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
n_check <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
stopifnot(all.equal(n, n_check)) # same number of samples for SNPs and traits within each eQTL problem
rm(n_check)

p # number of SNPs
q # number of traits in each eQTL problem
n # sample sizes in the five eQTL problems

bool_save <- FALSE # when TRUE, the analysis output is saved to a dedicated directory and the output and error messages are redirected to text files there.

if( bool_save ){
  res_dir <- paste0(out_dir, "atlasqtl_runs_seed_", seed, "/")
  dir.create(res_dir, showWarnings = FALSE)

  sink(paste(res_dir, "out.txt", sep = ""), append = F,
       split = T, type = "output")
  sink(file(paste(res_dir, "err.txt", sep = ""), open = "wt"),
       type = "message")
}
```

We illustrate the main package functionalities on the five eQTL problems 
(corresponding datasets stored in the list `list_data`). `atlasqtl` requires the 
specification of just two hyperparameters via the elicitation of a prior mean 
`mu_t` and variance `v_t` for the number of predictors associated with each 
response. The sensitivity of inference to these choices should be evaluated on a 
case-by-case basis; it is however very limited when a permutation-based FDR 
threshold is employed, where the "null-case" permutation runs use the same 
hyperparameter specifications. The remaining model parameters are inferred by 
variational inference. In particular, the horseshoe prior on the hotspot 
propensity circumvents ad-hoc choices of top-level variances (for which
inference is prone to spurious effects). This specification also has desirable 
multiplicity adjustment properties for dealing with the large-response case, see 
@ruffieux2020global.

The code below runs the five `atlasqtl` analyses in parallel. The annealing 
schedule (initial temperature, grid size and type of spacing) can be supplied 
via the argument `anneal` --- here we use a default geometric schedule on the 
inverse temperature, with initial temperature of $2$ and grid size $10$. The 
argument `add_collinear_back` is a boolean indicating whether or not to include 
the final posterior summaries for all possible collinear variables in $X$ (which 
are removed during the run to ensure the stability of inference). A number of 
additional settings (e.g., tolerance, maximum number of iterations, 
checkpointing, etc.) can be chosen by the user and are detailed on the help page 
of the function, which can be displayed by running `?atlasqtl`. Note that the 
parallel execution relies on the R package `parallel` which has already been 
installed as part of the `atlasqtl` installation.

\footnotesize
```{r atlasqtl-runs, include = TRUE, cache = TRUE, results = "hide"}
require(atlasqtl)

mu_t <- 1
v_t <- 4

vec_type <- names(list_data) # names of the eQTL problems 
                             # (resting, IFNg, LPS2h, 
                             # LPS24h monocytes and B-cells).

n_cpus <- 4 # nb of CPUs for parallel execution - please 
            # change this number according to your setup. 

list_out <- parallel::mclapply(vec_type, function(type) {

  snps <- list_data[[type]]$snps
  expr <- list_data[[type]]$expr
  
  atlasqtl(Y = expr, X = snps, 
           p0 = c(mu_t, v_t), 
           add_collinear_back = TRUE)
  
}, mc.cores = n_cpus)

names(list_out) <- vec_type
```
\normalsize 
The object returned by `atlasqtl` contains a range of useful posterior 
quantities, which can be employed to assess:

   * the pairwise associations between each pair of SNP and trait: using the 
variational posterior probabilities (PPIs) stored in `gam_vb`
($p \times q$ matrix) and the variational posterior means of the regression 
estimates stored in `beta_vb` ($p \times q$ matrix);
   * the hotspot propensities: using the variational posterior mean of $\theta_s$ 
stored in `theta_vb` (vector of length $p$).

It also contains diagnostic values on the final status of convergence and number 
of iterations used for the coordinate ascent variational algorithm.

The custom `print.atlasqtl` and `summary.atlasqtl` function provide information
about the run and a summary of the above posterior quantities; e.g., for the unstimulated-monocyte eQTL analysis:


```{r print-summary, echo=FALSE, results='hide'}
tol <- 0.1
maxit <- 1000
anneal <- c(1, 2, 10)
print_atlasqtl <- function(x, anneal, maxit, tol) {
  x$converged <- F
  if (x$converged) {
    cat(paste0("****************************************************** \n", 
               "Successful convergence after ", x$it, " iterations, using a\n", 
               "tolerance of ", tol, " on the absolute changes in the ELBO\n", 
               "****************************************************** \n\n"))
    
    if (!is.null(anneal)) {
      
      if (anneal[1] == 1) {
        anneal_type <- "Geometric"
      } else if (anneal[1] == 2) {
        anneal_type <- "Harmonic"
      } else if (anneal[1] == 3) {
        anneal_type <- "Linear"
      }
      cat(paste0(anneal_type, " annealing on the inverse temperature was\n", 
                 "applied for the first ", anneal[3], " iterations, with initial\n",
                 "temperature of ", anneal[2],
                 ifelse(all(anneal == c(1, 2, 10)), " (default).\n", ".\n")))
    }

  } else {
        cat(paste0("************************************************ \n", 
                   "Unsuccessful convergence after ", maxit, " iterations. \n",
                   "Difference between last two consecutive values\n", 
                   "of the ELBO: ", format(x$diff_lb, digits = 3), ".\n\n",
                   "Try increasing:\n", 
                   "- the maximum number of iterations (maxit) or\n", 
                   "- the convergence threshold (tol). \n",
                   "************************************************ \n\n"))
  }
}

summary.atlasqtl <- function(x) {
print(summary(as.vector(x$gam_vb))) # PPIs, pr(gamma = 1 | y)
    print(summary(as.vector(x$beta_vb))) # E(beta | y)
    print(summary(x$theta_vb)) 
    }

```

\footnotesize
```{r output-snapshot, include = TRUE}
print_atlasqtl(list_out$bcells, anneal, maxit, tol) # replace by list_out$bcells simply 

summary(list_out$bcells)
```
\normalsize 


```{r output-save, echo = FALSE}
if (bool_save) { # if `bool_save = TRUE`, the full output is saved in the directory created above.
  save(list_out, rt, file = paste(res_dir, "output.RData", sep = "")) 
}
```


Finally, we display a Manhattan-type plot which indicates the position of the
hotspots, as estimated in the five different eQTL analyses. 

Also note that permutation analyses can be run to compute calibrated Bayesian FDR 
thresholds on the PPIs; we don't implement this for computational economy and 
use an arbitrary threshold instead. The procedure to derive these 
permutation-based FDR threshold is described in details in @ruffieux2017efficient 
and @ruffieux2020global.

\footnotesize
```{r manhattan-plot, include = TRUE, fig.align = 'center'}
thres <- 0.8
list_rs_thres <- lapply(list_out, 
                        function(ll_type) 
                          rowSums(ll_type$gam_vb>thres))

vec_pch <- c(15, 4, 2, 21, 20)

plot(list_rs_thres[[1]], pch = vec_pch[1], 
     ylim = c(0, max(unlist(list_rs_thres))),
     main = "Hotspot sizes",
     xlab = "SNPs",
     ylab = paste0("sum_k PPI_jk > ", thres))
for (type_id in 2:5) {
  points(list_rs_thres[[type_id]], pch = vec_pch[type_id])
}
legend("topleft", legend = vec_type, pch = vec_pch, 
       bty = "n")
```
\normalsize 

```{r session-info, echo = FALSE, results='hide'}
sessionInfo() # for reproducibility
```

## References
