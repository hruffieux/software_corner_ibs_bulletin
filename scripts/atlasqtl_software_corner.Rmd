---
title: "atlasqtl: an R package for variable selection in sparse regression with hierarchically-related outcomes"
author: "Hélène Ruffieux"
date: "06/15/2022"
output:
  bookdown::pdf_document2: 
    toc: false
    number_sections: false
classoption:
  - twocolumn
geometry: margin=0.7in
bibliography: references.bib
---

```{r setup, echo=FALSE}

# We first set the data, output and main directories for the analysis (please 
# edit according to your own setup):

rm(list = ls())

CORE_DIR <- file.path(Sys.getenv("CORE_DIR"), "software_corner_ibs_bulletin/")

data_dir <- file.path(CORE_DIR, "data/")
fig_dir <- file.path(CORE_DIR, "figures/")
out_dir <- file.path(CORE_DIR, "output/")
main_dir <- file.path(CORE_DIR, "scripts/")
setwd(main_dir)
```

<!-- ### Context -->

Statistical problems 
<!-- involving high-dimensional set-ups  -->
in the high-dimensional setting multiply, prompted by 
the proliferation of technologies capable of measuring large volumes of 
information, whether on health and lifestyle parameters, molecular entities or 
even galaxies. As well as growing in dimension, the datasets collected are also 
growing in complexity, which calls for elaborate and flexible modelling 
approaches. When coupled with robust and efficient inference, Bayesian 
hierarchical modelling is a powerful framework for describing intricate 
dependencies at the scale required by current applications, while conveying 
uncertainty in a coherent fashion.

We present the R package `atlasqtl`, which implements a 
<!-- contributes to this endeavour by providing  -->
scalable hierarchical framework for variable selection in regression problems 
with high-dimensional predictor and response spaces.


## Model and inference 

The model consists of series of hierarchically-related spike-and-slab 
regressions that permit a borrowing of information across very large numbers of 
responses. A graphical representation of the model is provided in Figure 
\@ref(fig:figgm). Each pair of predictor $X_s$ and response $y_t$ has its 
corresponding regression coefficient $\beta_{st}$ and spike-and-slab binary 
latent variable $\gamma_{st}$, from which posterior probabilities of association 
are conveniently obtained, $\text{pr}(\gamma_{st} = 1 \mid y)$, and employed to 
implement Bayesian false discovery rate (bFDR) control. The model is also 
tailored to the detection of \emph{hotspots}, namely, predictors associated with 
several responses: the top-level hierarchy introduces a probit submodel which 
involves response-specific contributions to the spike-and-slab probability of 
association, via $\zeta_t$, and predictor-specific modulations of this 
contribution, via $\theta_s$. The latter parameter also acts as the propensity 
of predictor $X_s$ to be a hotspot and is assigned a horseshoe prior, which 
adapts to the overall problem sparsity (via the global scale $\sigma_0$), while 
flexibly capturing hotspots (via the Cauchy tail of the local scale $\lambda_s$). 
Joint inference require special attention as the binary latent matrix 
$\Gamma = \{\gamma_{st}\}$ creates a discrete search space of dimension 
$2^{p\times q}$. To overcome this complication, `atlasqtl` implements a 
variational inference algorithm based on a structured mean-field factorisation 
and efficient batch updates. The algorithm is augmented with simulated annealing 
schemes that improve the exploration of highly multimodal spaces by introducing 
so-called "temperature" parameters controling the degree of separation of 
the modes of the target distribution. The model and annealed 
variational algorithm are detailed in @ruffieux2020global.

<!-- `atlasqtl` provides an annealed variational inference routine for a  -->
<!-- series of hierarchically-related spike-and-slab regressions, thereby enabling  -->
<!-- information to be borrowed across very large numbers of responses. The model is  -->
<!-- also tailored to the detection of \emph{hotspots}, namely, predictors associated -->
<!-- with several responses, via a dedicated global-local horseshoe prior formulation. -->

`atlasqtl` can be employed in any sparse multiple-response regression 
setting. Hereafter we discuss a use case in the context of expression quantitative 
trait locus (eQTL) analysis, in which \emph{hotspot genetic variants}, 
controlling many molecular traits at once, may be responsible for important 
functional mechanisms --- such problems aim to clarify the genetic architecture 
underlying complex traits and disease by estimation associations between up to 
millions candidate predictors (genetic variants) and several thousands of 
responses (molecular traits, such as genomic, proteomic, metabolomic levels).

<!-- ### Model and algorithm -->

<!-- The model consists of a series of hierarchically-related regression, with $q$ centered responses, $y = (y_1, \ldots, y_q)$ and $p$ centered candidate predictors, $X = (X_1, \ldots, X_p)$ for $n$ samples ($n \ll p$). A graphical representation of the model is given in Figure XX.  -->
<!-- $$\begin{eqnarray} -->
<!-- y_t &\mid& \beta_t, \tau_t \sim \mathcal{N}_n\left( X\beta_t, \tau_t^{-1} I_n\right) , \hspace{4cm}  t = 1, \ldots, q\,,\nonumber\\ -->
<!-- \beta_{st} &\mid& \gamma_{st}, \tau_t, \sigma \sim \gamma_{st}\,\mathcal{N}\left( 0, \sigma^2\,\tau_{t}^{-1}\right)  + (1-\gamma_{st})\,\delta_0 \,, \hspace{1.45cm} s = 1, \ldots, p\,,\\ -->
<!-- \gamma_{st} &\mid&\theta_s, \zeta_t \sim \mathrm{Bern}\left\{ \Phi(\theta_s + \zeta_t) \right\},\qquad  \zeta_t \overset{\mathrm{iid}}{\sim}  \mathcal{N}(n_0, t_0^2),\nonumber\\ -->
<!-- \theta_s &\mid& \lambda_s, \sigma_0 \sim \mathcal{N}\left(0, \lambda_s^2 \sigma_0^2 \right), \qquad \lambda_s \overset{\mathrm{iid}}{\sim} \mathrm{C}^+(0, 1)\,, \qquad \sigma_0 \sim  \mathrm{C}^+(0, q^{-1/2})\,,\nonumber -->
<!-- \end{eqnarray}$$ -->
<!-- with Gamma prior distributions for $\tau_t$ and $\sigma^{-2}$; a graphical representation is given in Figure~\ref{fig_graph}. -->

<!-- ![Graphical representation of model (\ref{eq_all}). The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots.](../figures/gm.pdf){#id .class width=50% height=50%} -->

```{r figgm, echo=FALSE, fig.cap="Graphical representation of the model. The shaded nodes are observed, the others are inferred.", fig.align = 'center', out.width="90%"}
knitr::include_graphics("../figures/gm.png")
```

<!-- The shaded nodes are observed, the others are inferred; $\beta_{st}$ is the regression coefficient for association between predictor $X_s$ (SNP) and response $y_t$ (expression level), and $\gamma_{st}$ is the latent binary indicator for the presence or absence of this effect. The probability of association is decoupled into response-specific, $\zeta_t$, and predictor-specific, $\theta_s$, contributions. The latter entails the global-local second-stage model for hotspots. -->
## Installation

The hierarchical model and R package `atlasqtl` is written in R with C++ 
subroutines. It can be installed following the instructions provided at https://github.com/hruffieux/atlasqtl#installation. Note that the 
GSL library must be installed prior to installing the package.

## Data and reproducibility

The material (data and analysis scripts) used in this example is available at https://github.com/hruffieux/software_corner_ibs_bulletin
for replication purposes. It involves synthetic genotyping data which emulate 
the genotypes (single nucleotide polymorphisms - SNPs) for the *LYZ* gene region 
(the genotypes themselves require setting up a data access agreement and hence 
cannot be publicly shared). The expression data consist of resting (unstimulated) 
monocyte levels, monocyte levels obtained from three stimulated conditions (IFNg, 
LPS2h, LPS24h) and B-cells. To each of these transcriptomic datasets corresponds 
a separate eQTL problem. 

The two steps: 

  1) generation of synthetic SNPs from the real SNPs and 
  2) modification of the expression levels to simulate genetic associations
    
are done using our in-house R package `echoseq` available at 
https://github.com/hruffieux/echoseq. While 1) requires access to the 
real genotyping data, 2) can be run using the R script `prepare_data.R` 
available in https://github.com/hruffieux/software_corner_ibs_bulletin
-- alternatively, one can directly use the `prepared_data.RData` R object file 
which contains ready-to-use datasets. We restricted the analyses to the most 
variable transcriptomic levels and to the $250$ SNPs surrounding the *LYZ* gene 
to limit the data file sizes and have the five eQTL analyses run within seconds 
on a standard laptop (parallel execution can be enabled).


## Analysis

<!-- -- the full analysis script can -->
<!-- be accessed at https://github.com/hruffieux/software_corner_ibs_bulletin/blob/master/scripts/atlasqtl_software_corner.Rmd.  -->


```{r data, echo=FALSE, results='hide'}

# We set a seed for reproducibility. The random generator "L'Ecuyer-CMRG" 
# ensures reproducibility when parallel processes are used.

RNGkind("L'Ecuyer-CMRG")
seed <- 1
set.seed(seed)

# The SNP and monocyte expression data are loaded (see `"Data and reproducibility" 
# Section above for details).
load(file.path(data_dir, "prepared_data.RData"))
ls()
```

We next illustrate the main package functionalities on five different eQTL 
analyses (whose names, resting monocytes, IFNg, LPS2h, LPS24h monocytes and B-cells, 
are gathered in the vector `vec_type`, and which can be run in parallel =  here, 
using `n_cpus = 4` cpus). The corresponding datasets are stored in the list 
`list_data`.

```{r parallel-execution, echo = FALSE, results='hide'}
vec_type <- names(list_data) # the vector `vec_type` gathers the names of the eQTL problems (resting monocytes, IFNg, LPS2h, LPS24h monocytes and B-cells)

n_cpus <- 4 # Here we use the $4$ cores of our laptop, but please change this number according to your setup. Setting `n_cpus <- 1` corresponds to a serial execution (e.g., needed for Windows users).

p <- unique(sapply(list_data, function(ll_type) ncol(ll_type$snps)))
stopifnot(length(p) == 1) # all datasets involve the same number of SNPs

q <- unique(sapply(list_data, function(ll_type) ncol(ll_type$expr)))
stopifnot(length(q) == 1) # all datasets involve the same number of traits

n <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
n_check <- sapply(list_data, function(ll_type) nrow(ll_type$expr))
stopifnot(all.equal(n, n_check)) # same number of samples for SNPs and traits within each eQTL problem
rm(n_check)

vec_type
p # number of SNPs
q # number of traits in each eQTL problem
n # sample sizes in the five eQTL problems

bool_save <- FALSE # when TRUE, the analysis output is saved to a dedicated directory and the output and error messages are redirected to text files there.

if( bool_save ){
  res_dir <- paste0(out_dir, "atlasqtl_runs_seed_", seed, "/")
  dir.create(res_dir, showWarnings = FALSE)

  sink(paste(res_dir, "out.txt", sep = ""), append = F,
       split = T, type = "output")
  sink(file(paste(res_dir, "err.txt", sep = ""), open = "wt"),
       type = "message")
}
```

`atlasqtl` requires the specification of just two hyperparameters via the 
elicitation of a prior mean `mu_t` and variance `v_t` for the number of SNPs 
associated with each trait. The sensitivity of inference to these choices is 
typically limited, and essentially non existent once a permutation-based FDR 
threshold is employed (where the "null-case" permutation runs use the same prior 
specifications). 

The remaining model parameters are inferred by variational inference; in 
particular, the hotspot propensity is assigned a horseshoe prior which 
circumvent ad-hoc specifications of top-level variances (a case where inference 
is prone to strong biases). This specification also has desirable multiplicity 
adjustment properties for dealing with the large-response case, see 
@ruffieux2020global.

The next chunk runs the five ATLASQTL analyses in parallel, also storing the 
overall run time. We are using the default annealing setting, namely a geometric 
schedule on the inverse temperature, with initial temperature of $2$ and $10$ 
different temperatures. This specification, as well as alternative options,
are described in greater details on the help page of the function, by running
`?atlasqtl`. A number of additional settings (e.g., tolerance, maximum number of
iterations, checkpointing, etc.) are also detailed there.

Note that the parallel execution relies on the R package `parallel` which has 
already been installed as part of the `atlasqtl` installation.
\footnotesize
```{r atlasqtl-runs, include = TRUE, cache = TRUE, results = "hide"}
require(atlasqtl)

mu_t <- 1
v_t <- 4

list_out <- parallel::mclapply(vec_type, function(type) {

  snps <- list_data[[type]]$snps
  expr <- list_data[[type]]$expr

  stopifnot(rownames(snps) == rownames(expr))
  
  atlasqtl(Y = expr, X = snps, 
           p0 = c(mu_t, v_t), 
           add_collinear_back = TRUE)
  
}, mc.cores = n_cpus)

names(list_out) <- vec_type
```
\normalsize 
The object returned by `atlasqtl` contains a range of useful posterior 
quantities, which can be employed to assess:

   * the pairwise associations between each pair of SNP and trait: using the 
variational posterior probabilities (PPIs) stored in `gam_vb` 
($p \times q$ matrix) and the variational posterior means of the regression 
estimates stored in `beta_vb` ($p \times q$ matrix);
   * the hotspot propensities: using the variational posterior mean of $\theta_s$ 
stored in `theta_vb` (vector of length $p$).

It also contains diagnostic values on the final status of convergence and number of
iterations used for the coordinate ascent variational algorithm.

We print here a snapshot of these quantities for the first unstimulated-monocyte
eQTL analysis.

\footnotesize
```{r output-snapshot, include = TRUE}
atlasqtl_unstim <- list_out$unstim
summary(as.vector(atlasqtl_unstim$gam_vb)) # PPIs, pr(gamma = 1 | y)
summary(as.vector(atlasqtl_unstim$beta_vb)) # E(beta | y)
summary(atlasqtl_unstim$theta_vb) # E(theta | y)
```
\normalsize 


```{r output-save, echo = FALSE}
if (bool_save) { # if `bool_save = TRUE`, the full output is saved in the directory created above.
  save(list_out, rt, file = paste(res_dir, "output.RData", sep = "")) 
}
```


Finally, we display a Manhattan-type plot which indicates the position of the
hotspots, as estimated in the five different eQTL analyses. 

Also note that permutation analyses can be run to compute calibrated Bayesian FDR 
thresholds on the PPIs; we don't implement this for computational economy and 
use an arbitrary threshold instead. The procedure to derive these 
permutation-based FDR threshold is described in details in @ruffieux2017efficient 
and @ruffieux2020global.

\footnotesize
```{r manhattan-plot, include = TRUE, fig.align = 'center'}
thres <- 0.8
list_rs_thres <- lapply(list_out, 
                        function(ll_type) 
                          rowSums(ll_type$gam_vb>thres))

vec_pch <- c(15, 4, 2, 21, 20)

plot(list_rs_thres[[1]], pch = vec_pch[1], 
     ylim = c(0, max(unlist(list_rs_thres))),
     main = "Hotspot sizes",
     xlab = "SNPs",
     ylab = paste0("sum_k PPI_jk > ", thres))
for (type_id in 2:5) {
  points(list_rs_thres[[type_id]], pch = vec_pch[type_id])
}
legend("topleft", legend = vec_type, pch = vec_pch, 
       bty = "n")
```
\normalsize 

```{r session-info, echo = FALSE, results='hide'}
sessionInfo() # for reproducibility
```

## References
